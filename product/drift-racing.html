<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>ÊºÇÁßªËµõËΩ¶</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body { width: 100%; height: 100%; overflow: hidden; background: #1a1a2e; display: flex; justify-content: center; align-items: center; font-family: 'Courier New', monospace; }
canvas { display: block; image-rendering: pixelated; touch-action: none; }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
// ============================================================
// SECTION 1: CONFIG - ÂÖ®Â±ÄÂ∏∏ÈáèÈÖçÁΩÆ
// ============================================================
const CONFIG = {
    WIDTH: 400,
    HEIGHT: 700,
    FPS: 60,
    DT_MAX: 33,

    TRACK: {
        WIDTH: 280,
        GRASS_COLOR: '#2d5a1e',
        GRASS_COLOR2: '#265218',
        ROAD_COLOR: '#555',
        ROAD_COLOR2: '#4e4e4e',
        BORDER_COLOR: '#ccc',
        BORDER_WIDTH: 4,
        SEGMENT_HEIGHT: 4,
        CURVE_SMOOTHING: 0.015,
        MAX_CURVE: 55,
    },

    PLAYER: {
        WIDTH: 22,
        HEIGHT: 38,
        MAX_SPEED: 5.2,
        ACCELERATION: 0.11,
        BRAKE_FORCE: 0.16,
        FRICTION: 0.022,
        TURN_SPEED: 0.042,
        MAX_TURN: 0.45,
        DRIFT_FACTOR: 0.88,
        COLOR: '#e74c3c',
        SCREEN_Y: 0.72,
    },

    AI: {
        COUNT: 9,
        COLORS: ['#3498db','#2ecc71','#f39c12','#9b59b6','#1abc9c',
                 '#e67e22','#00bcd4','#ff69b4','#8bc34a'],
        SPEED_VAR: 0.14,
        LOOK_AHEAD: 120,
        LANE_SPEED: 2.2,
        AVOID_PAD: 28,
    },

    OBS: {
        TYPES: {
            BARRIER:  { w: 38, h: 16, color: '#c0392b', spd: 0 },
            ROCK:     { w: 26, h: 26, color: '#7f8c8d', spd: 0 },
            BARREL:   { w: 20, h: 20, color: '#d35400', spd: 0 },
            MOVER_H:  { w: 26, h: 16, color: '#8e44ad', spd: 1.4 },
            MOVER_V:  { w: 22, h: 22, color: '#c0392b', spd: 1.6 },
        },
        GAP: 55,
        INTERVAL: 140,
    },

    HIT: {
        SPEED_MULT: 0.4,
        BOUNCE: 3,
        FLASH_MS: 280,
    },

    LEVELS: [
        { len: 3000,  dens: 0.03, mov: 0,    nar: 0,  name: 'Á¨¨1ÂÖ≥' },
        { len: 3500,  dens: 0.04, mov: 0,    nar: 0,  name: 'Á¨¨2ÂÖ≥' },
        { len: 4000,  dens: 0.05, mov: 0,    nar: 0,  name: 'Á¨¨3ÂÖ≥' },
        { len: 5000,  dens: 0.06, mov: 0.2,  nar: 0,  name: 'Á¨¨4ÂÖ≥' },
        { len: 5500,  dens: 0.07, mov: 0.3,  nar: 12, name: 'Á¨¨5ÂÖ≥' },
        { len: 6500,  dens: 0.08, mov: 0.35, nar: 18, name: 'Á¨¨6ÂÖ≥' },
        { len: 7000,  dens: 0.09, mov: 0.4,  nar: 22, name: 'Á¨¨7ÂÖ≥' },
        { len: 7500,  dens: 0.10, mov: 0.45, nar: 28, name: 'Á¨¨8ÂÖ≥' },
        { len: 8500,  dens: 0.11, mov: 0.5,  nar: 34, name: 'Á¨¨9ÂÖ≥' },
        { len: 10000, dens: 0.12, mov: 0.55, nar: 42, name: 'Á¨¨10ÂÖ≥' },
    ],

    TRAIN: {
        INIT_DENS: 0.025,
        DENS_INC: 0.001,
        MAX_DENS: 0.10,
    },

    TOUCH: {
        SIZE: 50,
        PAD: 10,
        ALPHA: 0.28,
        ACTIVE_ALPHA: 0.55,
    },
};

// ============================================================
// SECTION 2: Utils - Â∑•ÂÖ∑ÂáΩÊï∞
// ============================================================
const U = {
    rand(a, b) { return Math.random() * (b - a) + a; },
    randI(a, b) { return Math.floor(this.rand(a, b + 1)); },
    clamp(v, lo, hi) { return v < lo ? lo : v > hi ? hi : v; },
    lerp(a, b, t) { return a + (b - a) * t; },
    rectHit(a, b) {
        return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
    },
};

// ============================================================
// SECTION 3: InputManager - ËæìÂÖ•ÁÆ°ÁêÜ
// ============================================================
class InputManager {
    constructor(cv) {
        this.keys = {};
        this.ts = { up: false, down: false, left: false, right: false };
        this.tpts = [];
        this.cv = cv;
        this.taps = [];
        this._initKB();
        this._initTouch();
    }
    _initKB() {
        window.addEventListener('keydown', e => {
            this.keys[e.code] = true;
            if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space','Escape'].includes(e.code)) e.preventDefault();
        });
        window.addEventListener('keyup', e => { this.keys[e.code] = false; });
    }
    _initTouch() {
        const cvt = (e) => {
            const r = this.cv.getBoundingClientRect();
            const sx = CONFIG.WIDTH / r.width, sy = CONFIG.HEIGHT / r.height;
            const pts = [];
            for (let i = 0; i < e.touches.length; i++) {
                pts.push({ x: (e.touches[i].clientX - r.left) * sx, y: (e.touches[i].clientY - r.top) * sy });
            }
            return pts;
        };
        const upd = (pts) => {
            this.ts = { up: false, down: false, left: false, right: false };
            const S = CONFIG.TOUCH.SIZE, P = CONFIG.TOUCH.PAD;
            const bx = P + S, by = CONFIG.HEIGHT - P - S;
            const zones = {
                up:    { x: bx - S/2, y: by - S*2 - P, w: S, h: S },
                down:  { x: bx - S/2, y: by, w: S, h: S },
                left:  { x: bx - S*1.5 - P, y: by - S - P/2, w: S, h: S },
                right: { x: bx + S/2 + P, y: by - S - P/2, w: S, h: S },
            };
            const E = 12;
            for (const pt of pts) {
                for (const d of ['up','down','left','right']) {
                    const z = zones[d];
                    if (pt.x >= z.x-E && pt.x <= z.x+z.w+E && pt.y >= z.y-E && pt.y <= z.y+z.h+E) this.ts[d] = true;
                }
            }
            this.tpts = pts;
        };
        this.cv.addEventListener('touchstart', e => { e.preventDefault(); const pts = cvt(e); upd(pts); for (const p of pts) for (const c of this.taps) c(p.x,p.y); }, { passive: false });
        this.cv.addEventListener('touchmove', e => { e.preventDefault(); upd(cvt(e)); }, { passive: false });
        this.cv.addEventListener('touchend', e => { e.preventDefault(); if (e.touches.length === 0) { this.ts = { up:false,down:false,left:false,right:false }; this.tpts = []; } else upd(cvt(e)); }, { passive: false });
        this.cv.addEventListener('click', e => {
            const r = this.cv.getBoundingClientRect();
            const x = (e.clientX - r.left) * CONFIG.WIDTH / r.width;
            const y = (e.clientY - r.top) * CONFIG.HEIGHT / r.height;
            for (const c of this.taps) c(x, y);
        });
    }
    onTap(fn) { this.taps.push(fn); }
    get up()    { return this.keys['ArrowUp']   || this.keys['KeyW'] || this.ts.up; }
    get down()  { return this.keys['ArrowDown'] || this.keys['KeyS'] || this.ts.down; }
    get left()  { return this.keys['ArrowLeft'] || this.keys['KeyA'] || this.ts.left; }
    get right() { return this.keys['ArrowRight']|| this.keys['KeyD'] || this.ts.right; }
    get esc()   { return this.keys['Escape']; }
    eatEsc()    { this.keys['Escape'] = false; }

    drawTouch(ctx) {
        const S = CONFIG.TOUCH.SIZE, P = CONFIG.TOUCH.PAD;
        const bx = P + S, by = CONFIG.HEIGHT - P - S;
        const btns = [
            { d:'up',   x: bx-S/2,       y: by-S*2-P,   sym:'‚ñ≤' },
            { d:'down', x: bx-S/2,       y: by,          sym:'‚ñº' },
            { d:'left', x: bx-S*1.5-P,   y: by-S-P/2,   sym:'‚óÄ' },
            { d:'right',x: bx+S/2+P,     y: by-S-P/2,   sym:'‚ñ∂' },
        ];
        for (const b of btns) {
            const on = this.ts[b.d];
            ctx.globalAlpha = on ? CONFIG.TOUCH.ACTIVE_ALPHA : CONFIG.TOUCH.ALPHA;
            ctx.fillStyle = '#fff';
            this._roundRect(ctx, b.x, b.y, S, S, 8);
            ctx.fill();
            ctx.globalAlpha = on ? 0.9 : 0.6;
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px sans-serif';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(b.sym, b.x+S/2, b.y+S/2);
        }
        ctx.globalAlpha = 1;
    }
    _roundRect(ctx, x, y, w, h, r) {
        ctx.beginPath();
        ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y); ctx.quadraticCurveTo(x+w,y,x+w,y+r);
        ctx.lineTo(x+w,y+h-r); ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
        ctx.lineTo(x+r,y+h); ctx.quadraticCurveTo(x,y+h,x,y+h-r);
        ctx.lineTo(x,y+r); ctx.quadraticCurveTo(x,y,x+r,y);
        ctx.closePath();
    }
}

// ============================================================
// SECTION 4: Camera
// ============================================================
class Camera {
    constructor() { this.y = 0; }
    follow(wy) { this.y = wy - CONFIG.HEIGHT * CONFIG.PLAYER.SCREEN_Y; }
    toScreen(wy) { return wy - this.y; }
}

// ============================================================
// SECTION 5: Track - ËµõÈÅì
// ============================================================
class Track {
    constructor() { this.segs = []; this.curveOff = 0; this.curveTgt = 0; this.genY = 0; this.finishY = -Infinity; this.nar = 0; }

    init(finishY, nar) {
        this.segs = []; this.curveOff = 0; this.curveTgt = 0; this.genY = 200; this.finishY = finishY; this.nar = nar || 0;
    }

    generate(camY) {
        const SH = CONFIG.TRACK.SEGMENT_HEIGHT;
        const top = camY - 200;
        while (this.genY > top) {
            this.genY -= SH;
            if (Math.random() < 0.012) this.curveTgt = U.rand(-CONFIG.TRACK.MAX_CURVE, CONFIG.TRACK.MAX_CURVE);
            this.curveOff = U.lerp(this.curveOff, this.curveTgt, CONFIG.TRACK.CURVE_SMOOTHING);
            const cx = CONFIG.WIDTH / 2 + this.curveOff;
            const hw = (CONFIG.TRACK.WIDTH - this.nar) / 2;
            this.segs.push({ y: this.genY, l: cx - hw, r: cx + hw });
        }
        const bot = camY + CONFIG.HEIGHT + 300;
        while (this.segs.length > 0 && this.segs[0].y > bot) this.segs.shift();
    }

    bounds(wy) {
        const SH = CONFIG.TRACK.SEGMENT_HEIGHT;
        for (let i = this.segs.length - 1; i >= 0; i--) {
            if (this.segs[i].y <= wy && this.segs[i].y + SH > wy) return this.segs[i];
        }
        const hw = (CONFIG.TRACK.WIDTH - this.nar) / 2;
        return { y: wy, l: CONFIG.WIDTH / 2 - hw, r: CONFIG.WIDTH / 2 + hw };
    }

    draw(ctx, cam) {
        // ËçâÂú∞
        ctx.fillStyle = CONFIG.TRACK.GRASS_COLOR;
        ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

        const SH = CONFIG.TRACK.SEGMENT_HEIGHT;
        for (let i = 0; i < this.segs.length; i++) {
            const s = this.segs[i];
            const sy = cam.toScreen(s.y);
            if (sy > CONFIG.HEIGHT + SH || sy < -SH) continue;

            // Ë∑ØÈù¢
            const stripe = (Math.floor(s.y / 24) & 1) === 0;
            ctx.fillStyle = stripe ? CONFIG.TRACK.ROAD_COLOR : CONFIG.TRACK.ROAD_COLOR2;
            ctx.fillRect(s.l, sy, s.r - s.l, SH);

            // ËçâÂú∞Êù°Á∫π
            const gstripe = (Math.floor(s.y / 16) & 1) === 0;
            if (gstripe) {
                ctx.fillStyle = CONFIG.TRACK.GRASS_COLOR2;
                ctx.fillRect(0, sy, s.l, SH);
                ctx.fillRect(s.r, sy, CONFIG.WIDTH - s.r, SH);
            }

            // ËæπÁïå
            ctx.fillStyle = CONFIG.TRACK.BORDER_COLOR;
            ctx.fillRect(s.l - CONFIG.TRACK.BORDER_WIDTH, sy, CONFIG.TRACK.BORDER_WIDTH, SH);
            ctx.fillRect(s.r, sy, CONFIG.TRACK.BORDER_WIDTH, SH);

            // Ë∑Ø‰∏≠ËôöÁ∫ø
            if ((Math.floor(s.y / 32) % 3) === 0) {
                ctx.fillStyle = 'rgba(255,255,255,0.25)';
                ctx.fillRect((s.l + s.r) / 2 - 1, sy, 2, SH);
            }
        }

        // ÁªàÁÇπÁ∫ø
        if (this.finishY > -Infinity) {
            const fsy = cam.toScreen(this.finishY);
            if (fsy > -40 && fsy < CONFIG.HEIGHT + 40) {
                const seg = this.bounds(this.finishY);
                const bs = 10;
                for (let x = seg.l; x < seg.r; x += bs) {
                    for (let row = 0; row < 3; row++) {
                        const col = Math.floor((x - seg.l) / bs);
                        ctx.fillStyle = (col + row) % 2 === 0 ? '#fff' : '#222';
                        ctx.fillRect(x, fsy + row * bs, bs, bs);
                    }
                }
            }
        }
    }
}

// ============================================================
// SECTION 6: Obstacle - ÈöúÁ¢çÁâ©
// ============================================================
class Obstacle {
    constructor(type, x, y, tl, tr) {
        const c = CONFIG.OBS.TYPES[type];
        this.type = type; this.x = x; this.y = y; this.w = c.w; this.h = c.h;
        this.color = c.color; this.spd = c.spd; this.baseX = x; this.baseY = y;
        this.tl = tl; this.tr = tr; this.dir = Math.random() < 0.5 ? 1 : -1;
    }
    update(dt) {
        if (this.type === 'MOVER_H') {
            this.x += this.spd * this.dir * dt;
            if (this.x <= this.tl + 4 || this.x + this.w >= this.tr - 4) this.dir *= -1;
            this.x = U.clamp(this.x, this.tl + 2, this.tr - this.w - 2);
        } else if (this.type === 'MOVER_V') {
            this.y += this.spd * this.dir * dt;
            if (Math.abs(this.y - this.baseY) > 35) this.dir *= -1;
        }
    }
    box() { return { x: this.x, y: this.y, w: this.w, h: this.h }; }
    draw(ctx, cam) {
        const sy = cam.toScreen(this.y);
        if (sy < -50 || sy > CONFIG.HEIGHT + 50) return;
        ctx.fillStyle = this.color;
        if (this.type === 'ROCK' || this.type === 'BARREL') {
            ctx.beginPath();
            ctx.arc(this.x + this.w/2, sy + this.h/2, this.w/2, 0, Math.PI*2);
            ctx.fill();
            if (this.type === 'BARREL') { ctx.strokeStyle = '#a04000'; ctx.lineWidth = 2; ctx.stroke(); }
        } else {
            ctx.fillRect(this.x, sy, this.w, this.h);
            ctx.fillStyle = 'rgba(255,255,255,0.15)';
            ctx.fillRect(this.x+2, sy+2, this.w-4, 3);
        }
        if (this.spd > 0) {
            ctx.fillStyle = 'rgba(255,255,0,0.6)';
            ctx.font = '9px sans-serif'; ctx.textAlign = 'center';
            ctx.fillText('‚ö†', this.x + this.w/2, sy - 2);
        }
    }
}

class ObstacleManager {
    constructor() { this.obs = []; this.spawnY = 0; }
    init(y) { this.obs = []; this.spawnY = y || 0; }

    generate(camY, dens, movR, track) {
        const tgt = camY - CONFIG.HEIGHT;
        while (this.spawnY > tgt) {
            this.spawnY -= CONFIG.OBS.INTERVAL;
            if (Math.random() > dens) continue;
            const seg = track.bounds(this.spawnY);
            const tw = seg.r - seg.l;
            if (tw < 50) continue;

            const statics = ['BARRIER','ROCK','BARREL'];
            const movers = ['MOVER_H','MOVER_V'];
            const cnt = U.randI(1, Math.min(3, Math.floor(tw / CONFIG.OBS.GAP)));
            const placed = [];

            for (let i = 0; i < cnt; i++) {
                const isM = Math.random() < movR;
                const pool = isM ? movers : statics;
                const type = pool[U.randI(0, pool.length - 1)];
                const cfg = CONFIG.OBS.TYPES[type];
                let x, ok = false, tries = 0;
                while (tries < 20 && !ok) {
                    x = U.rand(seg.l + 4, seg.r - cfg.w - 4);
                    ok = placed.every(p => Math.abs(x - p) >= CONFIG.OBS.GAP);
                    tries++;
                }
                if (ok) {
                    this.obs.push(new Obstacle(type, x, this.spawnY, seg.l, seg.r));
                    placed.push(x);
                }
            }
            this._checkGap(this.spawnY, seg);
        }
    }

    _checkGap(y, seg) {
        const row = this.obs.filter(o => Math.abs(o.y - y) < 8);
        if (!row.length) return;
        row.sort((a, b) => a.x - b.x);
        const minW = CONFIG.PLAYER.WIDTH + 8;
        const gaps = [];
        gaps.push(row[0].x - seg.l);
        for (let i = 0; i < row.length - 1; i++) gaps.push(row[i+1].x - (row[i].x + row[i].w));
        gaps.push(seg.r - (row[row.length-1].x + row[row.length-1].w));
        if (!gaps.some(g => g >= minW)) {
            const last = row[row.length - 1];
            const idx = this.obs.indexOf(last);
            if (idx >= 0) this.obs.splice(idx, 1);
        }
    }

    cleanup(camY) {
        this.obs = this.obs.filter(o => o.y < camY + CONFIG.HEIGHT + 200);
    }
    update(dt) { for (const o of this.obs) o.update(dt); }
    hit(box) { for (const o of this.obs) { if (U.rectHit(box, o.box())) return o; } return null; }
    draw(ctx, cam) { for (const o of this.obs) o.draw(ctx, cam); }
}

// ============================================================
// SECTION 7: Car - ËµõËΩ¶Âü∫Á±ª
// ============================================================
class Car {
    constructor(x, y, color) {
        this.x = x; this.wy = y; this.color = color;
        this.w = CONFIG.PLAYER.WIDTH; this.h = CONFIG.PLAYER.HEIGHT;
        this.spd = 0; this.ang = 0; this.vx = 0; this.flash = 0;
    }
    box() { return { x: this.x - this.w/2, y: this.wy - this.h/2, w: this.w, h: this.h }; }
    _drawCar(ctx, sx, sy) {
        ctx.save();
        ctx.translate(sx, sy);
        ctx.rotate(this.ang);
        const w = this.w, h = this.h;
        const fl = this.flash > 0 && (Math.floor(this.flash/50) & 1) === 0;
        // body
        ctx.fillStyle = fl ? '#fff' : this.color;
        ctx.fillRect(-w/2, -h/2, w, h);
        // windshield
        ctx.fillStyle = 'rgba(100,180,255,0.35)';
        ctx.fillRect(-w/2+3, -h/2+5, w-6, 9);
        // roof line
        ctx.fillStyle = 'rgba(255,255,255,0.25)';
        ctx.fillRect(-w/2+2, -h/2+1, w-4, 2);
        // tail lights
        ctx.fillStyle = '#ff4444';
        ctx.fillRect(-w/2+2, h/2-5, 4, 4);
        ctx.fillRect(w/2-6, h/2-5, 4, 4);
        // head lights
        ctx.fillStyle = '#ffee88';
        ctx.fillRect(-w/2+2, -h/2, 4, 3);
        ctx.fillRect(w/2-6, -h/2, 4, 3);
        ctx.restore();
    }
}

// ============================================================
// SECTION 8: PlayerCar
// ============================================================
class PlayerCar extends Car {
    constructor() { super(CONFIG.WIDTH/2, 0, CONFIG.PLAYER.COLOR); }
    reset(sy) {
        this.x = CONFIG.WIDTH/2; this.wy = sy || 0; this.spd = 0; this.ang = 0; this.vx = 0; this.flash = 0;
    }
    update(dt, inp, track) {
        const P = CONFIG.PLAYER;
        if (inp.up) this.spd += P.ACCELERATION * dt;
        else if (inp.down) this.spd -= P.BRAKE_FORCE * dt;
        else {
            if (Math.abs(this.spd) < P.FRICTION * dt) this.spd = 0;
            else this.spd -= P.FRICTION * dt * Math.sign(this.spd);
        }
        this.spd = U.clamp(this.spd, -P.MAX_SPEED * 0.3, P.MAX_SPEED);

        if (inp.left)  this.ang -= P.TURN_SPEED * dt * (this.spd > 0 ? 1 : -0.5);
        if (inp.right) this.ang += P.TURN_SPEED * dt * (this.spd > 0 ? 1 : -0.5);
        this.ang = U.clamp(this.ang, -P.MAX_TURN, P.MAX_TURN);
        if (!inp.left && !inp.right) { this.ang *= 0.92; if (Math.abs(this.ang) < 0.008) this.ang = 0; }

        const fx = Math.sin(this.ang) * this.spd;
        this.vx = U.lerp(this.vx, fx, 1 - P.DRIFT_FACTOR);
        this.x += this.vx * dt;
        this.wy -= this.spd * dt;

        const seg = track.bounds(this.wy);
        const hw = this.w / 2;
        if (this.x - hw < seg.l) { this.x = seg.l + hw; this.vx = 0; this.spd *= 0.7; }
        if (this.x + hw > seg.r) { this.x = seg.r - hw; this.vx = 0; this.spd *= 0.7; }
        if (this.flash > 0) this.flash -= dt * 16.67;
    }
    onHit(obs) {
        this.spd *= CONFIG.HIT.SPEED_MULT;
        this.flash = CONFIG.HIT.FLASH_MS;
        const dx = this.x - (obs.x + obs.w/2);
        this.vx += Math.sign(dx || 1) * CONFIG.HIT.BOUNCE;
        this.wy += CONFIG.HIT.BOUNCE * 0.8;
    }
    draw(ctx, cam) { this._drawCar(ctx, this.x, cam.toScreen(this.wy)); }
}

// ============================================================
// SECTION 9: AICar
// ============================================================
class AICar extends Car {
    constructor(i, col) { super(0, 0, col); this.idx = i; this.baseSp = 0; this.tgtX = 0; this.avDir = 0; }
    reset(sy, lvl) {
        const hw = (CONFIG.TRACK.WIDTH - (lvl ? lvl.nar : 0)) / 2;
        const cx = CONFIG.WIDTH / 2;
        this.x = U.rand(cx - hw + 18, cx + hw - 18);
        this.wy = sy + U.rand(-20, 20);
        this.spd = 0; this.ang = 0; this.vx = 0; this.flash = 0;
        this.tgtX = this.x; this.avDir = 0;
        this.baseSp = CONFIG.PLAYER.MAX_SPEED * U.rand(0.68 - CONFIG.AI.SPEED_VAR, 0.68 + CONFIG.AI.SPEED_VAR);
    }
    update(dt, om, track) {
        this.spd = U.lerp(this.spd, this.baseSp, 0.02 * dt);
        // obstacle avoidance
        let near = null, nd = Infinity;
        for (const o of om.obs) {
            const dy = this.wy - o.y;
            if (dy > 0 && dy < CONFIG.AI.LOOK_AHEAD) {
                if (Math.abs(this.x - (o.x + o.w/2)) < o.w/2 + this.w/2 + CONFIG.AI.AVOID_PAD) {
                    if (dy < nd) { nd = dy; near = o; }
                }
            }
        }
        if (near) {
            if (!this.avDir) this.avDir = this.x > near.x + near.w/2 ? 1 : -1;
            this.tgtX = this.x + this.avDir * CONFIG.AI.LANE_SPEED * dt * 18;
        } else {
            this.avDir = 0;
            if (Math.random() < 0.005) { const s = track.bounds(this.wy); this.tgtX = U.rand(s.l+18, s.r-18); }
        }
        const dx = this.tgtX - this.x;
        this.x += U.clamp(dx, -CONFIG.AI.LANE_SPEED*dt, CONFIG.AI.LANE_SPEED*dt) * 9;
        this.ang = U.clamp(dx * 0.008, -0.3, 0.3);
        this.wy -= this.spd * dt;

        const seg = track.bounds(this.wy);
        if (this.x - this.w/2 < seg.l + 4) { this.x = seg.l + this.w/2 + 4; this.avDir = 1; }
        if (this.x + this.w/2 > seg.r - 4) { this.x = seg.r - this.w/2 - 4; this.avDir = -1; }
        if (this.flash > 0) this.flash -= dt * 16.67;
    }
    onHit(obs) {
        this.spd *= CONFIG.HIT.SPEED_MULT;
        this.flash = CONFIG.HIT.FLASH_MS;
        const dx = this.x - (obs.x + obs.w/2);
        this.x += Math.sign(dx || 1) * CONFIG.HIT.BOUNCE;
        this.wy += CONFIG.HIT.BOUNCE * 0.4;
        this.avDir = Math.sign(dx || 1);
    }
    draw(ctx, cam) {
        const sy = cam.toScreen(this.wy);
        if (sy < -60 || sy > CONFIG.HEIGHT + 60) return;
        this._drawCar(ctx, this.x, sy);
    }
}

// ============================================================
// SECTION 10: HUD
// ============================================================
class HUD {
    constructor() { this.msg = ''; this.msgT = 0; }
    show(m, dur) { this.msg = m; this.msgT = dur || 2000; }
    tick(dt) { if (this.msgT > 0) this.msgT -= dt * 16.67; }

    drawRace(ctx, lv, tot, rank, cars, spd) {
        ctx.save();
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(0, 0, CONFIG.WIDTH, 36);
        ctx.fillStyle = '#fff'; ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText('üèÅ ' + lv + '/' + tot + 'ÂÖ≥', 10, 24);
        ctx.textAlign = 'center';
        ctx.fillText('Á¨¨' + rank + 'Âêç/' + cars + '‰∫∫', CONFIG.WIDTH/2, 24);
        ctx.textAlign = 'right';
        ctx.fillText(Math.abs(Math.round(spd * 30)) + ' km/h', CONFIG.WIDTH - 50, 24);
        ctx.restore();
        this._drawMsg(ctx);
    }
    drawTrain(ctx, dist, spd) {
        ctx.save();
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(0, 0, CONFIG.WIDTH, 36);
        ctx.fillStyle = '#fff'; ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText('üìè ' + Math.floor(dist) + ' m', 10, 24);
        ctx.textAlign = 'right';
        ctx.fillText(Math.abs(Math.round(spd * 30)) + ' km/h', CONFIG.WIDTH - 50, 24);
        ctx.restore();
        this._drawMsg(ctx);
    }
    _drawMsg(ctx) {
        if (this.msgT <= 0) return;
        const a = Math.min(1, this.msgT / 300);
        ctx.save(); ctx.globalAlpha = a;
        ctx.fillStyle = 'rgba(0,0,0,0.65)';
        ctx.fillRect(CONFIG.WIDTH/2 - 130, CONFIG.HEIGHT/2 - 45, 260, 90);
        ctx.fillStyle = '#fff'; ctx.font = 'bold 22px sans-serif';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(this.msg, CONFIG.WIDTH/2, CONFIG.HEIGHT/2);
        ctx.restore();
    }
}

// ============================================================
// SECTION 11: Game - ‰∏ªÊéß
// ============================================================
class Game {
    constructor() {
        this.cv = document.getElementById('gameCanvas');
        this.ctx = this.cv.getContext('2d');
        this.inp = new InputManager(this.cv);
        this.cam = new Camera();
        this.track = new Track();
        this.om = new ObstacleManager();
        this.hud = new HUD();
        this.player = new PlayerCar();
        this.ais = [];

        this.state = 'menu';
        this.mode = '';
        this.lv = 0;
        this.dist = 0;
        this.startY = 0;
        this.cdVal = 3;
        this.cdTimer = 0;
        this.lcTimer = 0;
        this.ranks = [];
        this.finalRanks = [];
        this.lastT = 0;

        this._resize();
        window.addEventListener('resize', () => this._resize());
        this.inp.onTap((x, y) => this._tap(x, y));
        this._loop = this._loop.bind(this);
        requestAnimationFrame(this._loop);
    }

    _resize() {
        const r = CONFIG.WIDTH / CONFIG.HEIGHT;
        let w = window.innerWidth, h = window.innerHeight;
        if (w / h > r) w = h * r; else h = w / r;
        this.cv.width = CONFIG.WIDTH; this.cv.height = CONFIG.HEIGHT;
        this.cv.style.width = w + 'px'; this.cv.style.height = h + 'px';
    }

    // -- state transitions --
    _goMenu() { this.state = 'menu'; this.mode = ''; }

    _goRace(lv) {
        this.mode = 'race'; this.lv = lv;
        const c = CONFIG.LEVELS[lv];
        this.startY = 0;
        this.track.init(-c.len, c.nar);
        this.track.generate(0);
        this.player.reset(0);
        this.om.init(0);
        this.ais = [];
        for (let i = 0; i < CONFIG.AI.COUNT; i++) {
            const ai = new AICar(i, CONFIG.AI.COLORS[i]);
            ai.reset(0, c);
            this.ais.push(ai);
        }
        this._goCountdown();
    }

    _goTrain() {
        this.mode = 'training'; this.startY = 0; this.dist = 0;
        this.track.init(-Infinity, 0);
        this.track.generate(0);
        this.player.reset(0);
        this.om.init(0);
        this.ais = [];
        this._goCountdown();
    }

    _goCountdown() { this.state = 'countdown'; this.cdVal = 3; this.cdTimer = 0; }
    _goPause() { if (this.state === 'playing') this.state = 'paused'; }
    _goResume() { if (this.state === 'paused') this.state = 'playing'; }

    _goNext() {
        if (this.lv < CONFIG.LEVELS.length - 1) this._goRace(this.lv + 1);
        else { this.finalRanks = this.ranks.slice(); this.state = 'victory'; }
    }

    // -- tap --
    _tap(x, y) {
        const cx = CONFIG.WIDTH / 2;
        if (this.state === 'menu') {
            if (x >= cx - 100 && x <= cx + 100) {
                if (y >= 340 && y <= 395) this._goTrain();
                if (y >= 415 && y <= 470) this._goRace(0);
            }
        } else if (this.state === 'paused') {
            if (x >= cx - 90 && x <= cx + 90) {
                if (y >= 295 && y <= 345) this._goResume();
                if (y >= 360 && y <= 410) { this.mode === 'race' ? this._goRace(this.lv) : this._goTrain(); }
                if (y >= 425 && y <= 475) this._goMenu();
            }
        } else if (this.state === 'playing') {
            // pause btn area (top-right)
            if (x >= CONFIG.WIDTH - 48 && y <= 36) this._goPause();
            // training end btn
            if (this.mode === 'training' && x >= CONFIG.WIDTH - 98 && x <= CONFIG.WIDTH - 8 && y >= 42 && y <= 72) {
                this.state = 'trainEnd';
            }
        } else if (this.state === 'trainEnd') {
            if (x >= cx - 90 && x <= cx + 90) {
                if (y >= 360 && y <= 410) this._goTrain();
                if (y >= 425 && y <= 475) this._goMenu();
            }
        } else if (this.state === 'victory') {
            if (x >= cx - 90 && x <= cx + 90 && y >= 470 && y <= 520) this._goMenu();
        }
    }

    // -- update --
    _update(dt) {
        if (this.inp.esc) {
            this.inp.eatEsc();
            if (this.state === 'playing') this._goPause();
            else if (this.state === 'paused') this._goResume();
        }
        this.hud.tick(dt);

        if (this.state === 'countdown') {
            this.cdTimer += dt * 16.67;
            if (this.cdTimer >= 1000) { this.cdTimer -= 1000; this.cdVal--; if (this.cdVal < 0) this.state = 'playing'; }
        } else if (this.state === 'playing') {
            this._play(dt);
        } else if (this.state === 'levelComplete') {
            this.lcTimer -= dt * 16.67;
            if (this.lcTimer <= 0) this._goNext();
        }
    }

    _play(dt) {
        this.player.update(dt, this.inp, this.track);
        this.cam.follow(this.player.wy);
        this.track.generate(this.cam.y);

        // obstacles gen
        if (this.mode === 'race') {
            const c = CONFIG.LEVELS[this.lv];
            this.om.generate(this.cam.y, c.dens, c.mov, this.track);
        } else {
            const d = Math.abs(this.player.wy - this.startY);
            const dens = Math.min(CONFIG.TRAIN.MAX_DENS, CONFIG.TRAIN.INIT_DENS + Math.floor(d / 1000) * CONFIG.TRAIN.DENS_INC);
            this.om.generate(this.cam.y, dens, Math.min(0.4, d / 20000), this.track);
        }
        this.om.update(dt);
        this.om.cleanup(this.cam.y + CONFIG.HEIGHT);

        // player collision
        if (this.player.flash <= 0) { const h = this.om.hit(this.player.box()); if (h) this.player.onHit(h); }

        // AI
        for (const ai of this.ais) {
            ai.update(dt, this.om, this.track);
            if (ai.flash <= 0) { const h = this.om.hit(ai.box()); if (h) ai.onHit(h); }
        }

        // ranks
        if (this.mode === 'race') this._calcRanks();

        // distance (training)
        if (this.mode === 'training') this.dist = Math.abs(this.player.wy - this.startY) / 10;

        // finish check
        if (this.mode === 'race') {
            const c = CONFIG.LEVELS[this.lv];
            if (this.player.wy <= -c.len) {
                this.state = 'levelComplete';
                this.lcTimer = 2000;
                this.hud.show(c.name + 'ÂÆåÊàêÔºÅ Á¨¨' + this._pRank() + 'Âêç', 2000);
            }
        }
    }

    _calcRanks() {
        const all = [{ c: this.player, p: true }];
        for (const a of this.ais) all.push({ c: a, p: false });
        all.sort((a, b) => a.c.wy - b.c.wy);
        this.ranks = all;
    }
    _pRank() { for (let i = 0; i < this.ranks.length; i++) if (this.ranks[i].p) return i + 1; return this.ranks.length; }

    // -- draw --
    _draw() {
        const ctx = this.ctx;
        ctx.clearRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

        switch (this.state) {
            case 'menu': this._drawMenu(ctx); break;
            case 'countdown': this._drawGame(ctx); this._drawCD(ctx); break;
            case 'playing': this._drawGame(ctx); this._drawHUD(ctx); break;
            case 'paused': this._drawGame(ctx); this._drawPause(ctx); break;
            case 'levelComplete': this._drawGame(ctx); this.hud._drawMsg(ctx); break;
            case 'victory': this._drawVictory(ctx); break;
            case 'trainEnd': this._drawTrainEnd(ctx); break;
        }
    }

    _drawGame(ctx) {
        this.track.draw(ctx, this.cam);
        this.om.draw(ctx, this.cam);
        for (const a of this.ais) a.draw(ctx, this.cam);
        this.player.draw(ctx, this.cam);
        this.inp.drawTouch(ctx);
    }

    _drawHUD(ctx) {
        if (this.mode === 'race') {
            this.hud.drawRace(ctx, this.lv+1, CONFIG.LEVELS.length, this._pRank(), CONFIG.AI.COUNT+1, this.player.spd);
        } else {
            this.hud.drawTrain(ctx, this.dist, this.player.spd);
            // end btn
            ctx.save(); ctx.globalAlpha = 0.7;
            ctx.fillStyle = '#c0392b';
            this._rrect(ctx, CONFIG.WIDTH-98, 42, 88, 28, 6); ctx.fill();
            ctx.fillStyle = '#fff'; ctx.font = 'bold 13px sans-serif';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText('ÁªìÊùüËÆ≠ÁªÉ', CONFIG.WIDTH-54, 56);
            ctx.globalAlpha = 1; ctx.restore();
        }
        // pause icon
        ctx.save(); ctx.globalAlpha = 0.5; ctx.fillStyle = '#fff';
        ctx.fillRect(CONFIG.WIDTH - 38, 9, 7, 18);
        ctx.fillRect(CONFIG.WIDTH - 26, 9, 7, 18);
        ctx.globalAlpha = 1; ctx.restore();
        this.hud._drawMsg(ctx);
    }

    _drawMenu(ctx) {
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);
        // decorative track
        ctx.fillStyle = CONFIG.TRACK.ROAD_COLOR;
        ctx.fillRect(60, 0, 280, CONFIG.HEIGHT);
        ctx.fillStyle = CONFIG.TRACK.BORDER_COLOR;
        ctx.fillRect(57, 0, 3, CONFIG.HEIGHT);
        ctx.fillRect(340, 0, 3, CONFIG.HEIGHT);
        for (let y = 0; y < CONFIG.HEIGHT; y += 40) {
            ctx.fillStyle = 'rgba(255,255,255,0.12)';
            ctx.fillRect(198, y, 4, 20);
        }
        // title
        ctx.fillStyle = '#e74c3c';
        ctx.font = 'bold 40px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText('üèéÔ∏è ÊºÇÁßªËµõËΩ¶', CONFIG.WIDTH/2, 180);
        ctx.fillStyle = 'rgba(255,255,255,0.45)'; ctx.font = '13px sans-serif';
        ctx.fillText('ÊñπÂêëÈîÆ / WASD ÊìçÊéß ¬∑ ÊâãÊú∫Ëß¶ÊéßÊìç‰Ωú', CONFIG.WIDTH/2, 250);
        // buttons
        this._btn(ctx, CONFIG.WIDTH/2, 365, 'üèãÔ∏è ËÆ≠ÁªÉÊ®°Âºè', '#27ae60');
        this._btn(ctx, CONFIG.WIDTH/2, 440, 'üèÜ ÊØîËµõÊ®°Âºè', '#2980b9');
        ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.font = '12px sans-serif';
        ctx.fillText('ËÆ≠ÁªÉÔºöËá™Áî±ÁªÉ‰π† ¬∑ Êó†ÁªàÁÇπ ¬∑ Ëá™Â∑±‰∏Ä‰∏™‰∫∫', CONFIG.WIDTH/2, 520);
        ctx.fillText('ÊØîËµõÔºö10‰∫∫Á´ûÊäÄ ¬∑ 10ÂÖ≥ÈóØÂÖ≥ ¬∑ Ë∂äÊù•Ë∂äÈöæ', CONFIG.WIDTH/2, 540);
    }

    _drawCD(ctx) {
        ctx.save();
        ctx.fillStyle = 'rgba(0,0,0,0.45)';
        ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);
        ctx.fillStyle = '#fff'; ctx.font = 'bold 68px sans-serif';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(this.cdVal > 0 ? this.cdVal : 'GO!', CONFIG.WIDTH/2, CONFIG.HEIGHT/2);
        if (this.mode === 'race') {
            ctx.font = 'bold 20px sans-serif';
            ctx.fillText(CONFIG.LEVELS[this.lv].name, CONFIG.WIDTH/2, CONFIG.HEIGHT/2 - 70);
        }
        ctx.restore();
    }

    _drawPause(ctx) {
        ctx.save();
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);
        ctx.fillStyle = '#fff'; ctx.font = 'bold 28px sans-serif';
        ctx.textAlign = 'center'; ctx.fillText('ÊöÇÂÅú', CONFIG.WIDTH/2, 240);
        this._btn(ctx, CONFIG.WIDTH/2, 320, '‚ñ∂ ÁªßÁª≠Ê∏∏Êàè', '#27ae60');
        this._btn(ctx, CONFIG.WIDTH/2, 385, 'üîÑ ÈáçÊñ∞ÂºÄÂßã', '#f39c12');
        this._btn(ctx, CONFIG.WIDTH/2, 450, 'üè† ËøîÂõûËèúÂçï', '#c0392b');
        ctx.restore();
    }

    _drawVictory(ctx) {
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);
        ctx.fillStyle = '#f1c40f'; ctx.font = 'bold 34px sans-serif';
        ctx.textAlign = 'center'; ctx.fillText('üèÜ ÊØîËµõÂÆåÊàêÔºÅ', CONFIG.WIDTH/2, 100);
        const r = this._pRank();
        ctx.fillStyle = '#fff'; ctx.font = 'bold 22px sans-serif';
        ctx.fillText('ÊúÄÁªàÊéíÂêçÔºöÁ¨¨ ' + r + ' Âêç', CONFIG.WIDTH/2, 170);
        ctx.font = '15px sans-serif';
        const list = this.finalRanks.length ? this.finalRanks : this.ranks;
        for (let i = 0; i < Math.min(10, list.length); i++) {
            const e = list[i];
            ctx.fillStyle = e.p ? '#e74c3c' : e.c.color;
            const lb = e.p ? 'üë§ ‰Ω†' : 'ü§ñ AI-' + (e.c.idx + 1);
            ctx.fillText((i+1) + '. ' + lb, CONFIG.WIDTH/2, 220 + i * 22);
        }
        this._btn(ctx, CONFIG.WIDTH/2, 490, 'üè† ËøîÂõûËèúÂçï', '#2980b9');
    }

    _drawTrainEnd(ctx) {
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);
        ctx.fillStyle = '#f1c40f'; ctx.font = 'bold 30px sans-serif';
        ctx.textAlign = 'center'; ctx.fillText('ËÆ≠ÁªÉÁªìÊùü', CONFIG.WIDTH/2, 200);
        ctx.fillStyle = '#fff'; ctx.font = 'bold 22px sans-serif';
        ctx.fillText('Ë°åÈ©∂Ë∑ùÁ¶ªÔºö' + Math.floor(this.dist) + ' m', CONFIG.WIDTH/2, 280);
        ctx.fillStyle = 'rgba(255,255,255,0.5)'; ctx.font = '15px sans-serif';
        ctx.fillText('ÊúÄÁªàÈÄüÂ∫¶Ôºö' + Math.abs(Math.round(this.player.spd * 30)) + ' km/h', CONFIG.WIDTH/2, 320);
        this._btn(ctx, CONFIG.WIDTH/2, 385, 'üîÑ ÂÜçÊ¨°ËÆ≠ÁªÉ', '#27ae60');
        this._btn(ctx, CONFIG.WIDTH/2, 450, 'üè† ËøîÂõûËèúÂçï', '#c0392b');
    }

    _btn(ctx, cx, cy, txt, col) {
        const bw = 190, bh = 48;
        ctx.fillStyle = col;
        this._rrect(ctx, cx - bw/2, cy - bh/2, bw, bh, 10);
        ctx.fill();
        ctx.fillStyle = '#fff'; ctx.font = 'bold 17px sans-serif';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(txt, cx, cy);
    }
    _rrect(ctx, x, y, w, h, r) {
        ctx.beginPath();
        ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y); ctx.quadraticCurveTo(x+w,y,x+w,y+r);
        ctx.lineTo(x+w,y+h-r); ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
        ctx.lineTo(x+r,y+h); ctx.quadraticCurveTo(x,y+h,x,y+h-r);
        ctx.lineTo(x,y+r); ctx.quadraticCurveTo(x,y,x+r,y);
        ctx.closePath();
    }

    // -- loop --
    _loop(now) {
        if (!this.lastT) this.lastT = now;
        let el = now - this.lastT;
        this.lastT = now;
        if (el > CONFIG.DT_MAX) el = CONFIG.DT_MAX;
        const dt = el / 16.67;
        this._update(dt);
        this._draw();
        requestAnimationFrame(this._loop);
    }
}

// ============================================================
// SECTION 12: ÂêØÂä®ÂÖ•Âè£
// ============================================================
window.addEventListener('DOMContentLoaded', () => {
    new Game();
});
</script>
</body>
</html>